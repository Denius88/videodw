import os
import logging
import asyncio
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackQueryHandler, ContextTypes, ConversationHandler
import yt_dlp
import ffmpeg
import shutil
import concurrent.futures
import re
import json

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# –°—Ç–∞–Ω–∏ –≤ —è–∫–∏—Ö –º–æ–∂–µ –ø–µ—Ä–µ–±—É–≤–∞—Ç–∏ —Ä–æ–∑–º–æ–≤–∞
WAITING_FOR_INSTAGRAM_LINK, WAITING_FOR_TIKTOK_LINK = range(2)

# –ü–∞–ø–∫–∞ –¥–ª—è —Ç–∏–º—á–∞—Å–æ–≤–∏—Ö —Ñ–∞–π–ª—ñ–≤
TEMP_FOLDER = "temp_downloads"
os.makedirs(TEMP_FOLDER, exist_ok=True)

# –°–ª–æ–≤–Ω–∏–∫ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—å
active_downloads = {}

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ—á–∏—â–µ–Ω–Ω—è —Ç–∏–º—á–∞—Å–æ–≤–∏—Ö —Ñ–∞–π–ª—ñ–≤
def cleanup_temp_files(user_id):
    user_folder = os.path.join(TEMP_FOLDER, str(user_id))
    if os.path.exists(user_folder):
        try:
            shutil.rmtree(user_folder)
            logger.info(f"–û—á–∏—â–µ–Ω–æ —Ç–∏–º—á–∞—Å–æ–≤—ñ —Ñ–∞–π–ª–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")
        except Exception as e:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ—á–∏—â–µ–Ω–Ω—è —Ç–∏–º—á–∞—Å–æ–≤–∏—Ö —Ñ–∞–π–ª—ñ–≤: {str(e)}")

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # Create persistent Start button with custom text
    start_keyboard = [[KeyboardButton("üîÑ –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é")]]  # Changed button text, still sends /start
    start_markup = ReplyKeyboardMarkup(
        start_keyboard,
        resize_keyboard=True,
        one_time_keyboard=False
    )

    # Remove YouTube button, keep only Instagram and TikTok
    inline_keyboard = [
        [InlineKeyboardButton("üì∏ Instagram", callback_data="instagram")],
        [InlineKeyboardButton("üéµ TikTok", callback_data="tiktok")]
    ]
    inline_markup = InlineKeyboardMarkup(inline_keyboard)

    # Send message with both keyboards
    await update.message.reply_text(
        "–ü—Ä–∏–≤—ñ—Ç! –Ø –¥–æ–ø–æ–º–æ–∂—É –≤–∞–º –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –≤—ñ–¥–µ–æ –∑ Instagram —Ç–∞ TikTok.",
        reply_markup=start_markup
    )
    await update.message.reply_text(
        "–û–±–µ—Ä—ñ—Ç—å –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:",
        reply_markup=inline_markup
    )
    return ConversationHandler.END

# Add Instagram button handler
async def instagram_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(text="–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –≤—ñ–¥–µ–æ –∑ Instagram:")
    return WAITING_FOR_INSTAGRAM_LINK

# Add TikTok button handler
async def tiktok_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(text="–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–¥—ñ—à–ª—ñ—Ç—å –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ TikTok –≤—ñ–¥–µ–æ:")
    return WAITING_FOR_TIKTOK_LINK

# Add Instagram link processing function
async def process_instagram_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    instagram_link = update.message.text.strip()
    
    if not re.match(r'https?://(?:www\.)?instagram\.com/(?:p|reel|share)/[\w-]+/?', instagram_link):
        await update.message.reply_text("–¶–µ –Ω–µ —Å—Ö–æ–∂–µ –Ω–∞ –∫–æ—Ä–µ–∫—Ç–Ω–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è Instagram. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
        return WAITING_FOR_INSTAGRAM_LINK

    message = await update.message.reply_text("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä–æ–∑–ø–æ—á–∞—Ç–æ... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.")
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    output_folder = os.path.join(TEMP_FOLDER, str(user_id))
    os.makedirs(output_folder, exist_ok=True)

    try:
        ydl_opts = {
            'format': '(mp4)[width>=0][height>=0]',  # Changed format specification
            'outtmpl': os.path.join(output_folder, 'instagram_video.%(ext)s'),
            'quiet': False,
            'no_warnings': False,
            'merge_output_format': 'mp4',  # Added to ensure MP4 output
            'postprocessors': [{
                'key': 'FFmpegVideoConvertor',
                'preferedformat': 'mp4',
            }],
            'extract_flat': False,
            'nocheckcertificate': True,
            'addheader': [
                ('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'),
                ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'),
                ('Accept-Language', 'en-US,en;q=0.5'),
            ]
        }

        video_path = os.path.join(output_folder, 'instagram_video.mp4')
        await message.edit_text("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≤—ñ–¥–µ–æ...")

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([instagram_link])
        except Exception as e:
            logger.error(f"First attempt failed: {str(e)}")
            # Fallback to simpler format
            ydl_opts['format'] = 'best[ext=mp4]/best'
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([instagram_link])

        # Rest of the function remains the same
        if not os.path.exists(video_path):
            mp4_files = [f for f in os.listdir(output_folder) if f.endswith('.mp4')]
            if mp4_files:
                video_path = os.path.join(output_folder, mp4_files[0])
            else:
                raise Exception("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–µ –≤—ñ–¥–µ–æ")

        file_size = os.path.getsize(video_path) / (1024 * 1024)
        if file_size == 0:
            raise Exception("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∏–π —Ñ–∞–π–ª –ø–æ—Ä–æ–∂–Ω—ñ–π")

        # The rest of your existing code...
        await message.edit_text("–ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –≤—ñ–¥–µ–æ –≤ —á–∞—Ç...")
        
        with open(video_path, 'rb') as video_file:
            await context.bot.send_video(
                chat_id=chat_id,
                video=video_file,
                caption="–û—Å—å –≤–∞—à–µ –≤—ñ–¥–µ–æ –∑ Instagram!",
                supports_streaming=True
            )

        # Return to main menu
        keyboard = [
            [InlineKeyboardButton("üì∏ Instagram", callback_data="instagram")],
            [InlineKeyboardButton("üéµ TikTok", callback_data="tiktok")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=chat_id,
            text="–ì–æ—Ç–æ–≤–æ! –©–æ –±–∞–∂–∞—î—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ –¥–∞–ª—ñ?",
            reply_markup=reply_markup
        )

    except Exception as e:
        error_message = f"–ü–æ–º–∏–ª–∫–∞: {str(e)}"
        logger.error(error_message)
        await context.bot.send_message(chat_id=chat_id, text=error_message)

    finally:
        await asyncio.to_thread(cleanup_temp_files, user_id)
        try:
            await message.delete()
        except Exception:
            pass

    return ConversationHandler.END

# Add TikTok processing function
async def process_tiktok_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    tiktok_link = update.message.text.strip()
    
    if not re.match(r'https?://(?:www\.|vm\.)?tiktok\.com/', tiktok_link):
        await update.message.reply_text("–¶–µ –Ω–µ —Å—Ö–æ–∂–µ –Ω–∞ –∫–æ—Ä–µ–∫—Ç–Ω–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è TikTok. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.")
        return WAITING_FOR_TIKTOK_LINK

    message = await update.message.reply_text("–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä–æ–∑–ø–æ—á–∞—Ç–æ... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.")
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    output_folder = os.path.join(TEMP_FOLDER, str(user_id))
    os.makedirs(output_folder, exist_ok=True)

    try:
        ydl_opts = {
            'format': 'best',
            'outtmpl': os.path.join(output_folder, 'tiktok_video.%(ext)s'),
            'quiet': False,
            'no_warnings': False,
            'extract_flat': False,
            'nocheckcertificate': True,
            'addheader': [
                ('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'),
                ('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'),
            ]
        }

        video_path = os.path.join(output_folder, 'tiktok_video.mp4')
        await message.edit_text("–û—Ç—Ä–∏–º–∞–Ω–Ω—è –≤—ñ–¥–µ–æ –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫—É...")

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(tiktok_link, download=False)
            if info.get('duration', 0) == 0:
                raise Exception("–¶–µ —Ñ–æ—Ç–æ –∞–±–æ GIF. –ë–æ—Ç –ø—ñ–¥—Ç—Ä–∏–º—É—î –ª–∏—à–µ –≤—ñ–¥–µ–æ –∑ TikTok.")
            
            # Download without watermark
            ydl.download([tiktok_link])

        if not os.path.exists(video_path):
            mp4_files = [f for f in os.listdir(output_folder) if f.endswith('.mp4')]
            if mp4_files:
                video_path = os.path.join(output_folder, mp4_files[0])
            else:
                raise Exception("–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–µ –≤—ñ–¥–µ–æ")

        await message.edit_text("–ù–∞–¥—Å–∏–ª–∞–Ω–Ω—è –≤—ñ–¥–µ–æ –≤ —á–∞—Ç...")
        
        with open(video_path, 'rb') as video_file:
            await context.bot.send_video(
                chat_id=chat_id,
                video=video_file,
                caption="–û—Å—å –≤–∞—à–µ –≤—ñ–¥–µ–æ –∑ TikTok!",
                supports_streaming=True
            )

        # Return to main menu
        keyboard = [
            [InlineKeyboardButton("üì∏ Instagram", callback_data="instagram")],
            [InlineKeyboardButton("üéµ TikTok", callback_data="tiktok")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=chat_id,
            text="–ì–æ—Ç–æ–≤–æ! –©–æ –±–∞–∂–∞—î—Ç–µ –∑—Ä–æ–±–∏—Ç–∏ –¥–∞–ª—ñ?",
            reply_markup=reply_markup
        )

    except Exception as e:
        error_message = f"–ü–æ–º–∏–ª–∫–∞: {str(e)}"
        logger.error(error_message)
        await context.bot.send_message(chat_id=chat_id, text=error_message)

    finally:
        await asyncio.to_thread(cleanup_temp_files, user_id)
        try:
            await message.delete()
        except Exception:
            pass

    return ConversationHandler.END

# –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
def compress_video_sync(input_file, output_file, width, height, video_bitrate, audio_bitrate='128k', crf=23, preset='medium'):
    try:
        (
            ffmpeg
            .input(input_file)
            .output(
                output_file,
                vf=f"scale={width}:{height}",
                video_bitrate=video_bitrate,
                audio_bitrate=audio_bitrate,
                crf=crf,
                preset=preset
            )
            .run(quiet=True, overwrite_output=True)
        )
        return os.path.exists(output_file)
    except Exception as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∫–æ–º–ø—Ä–µ—Å—ñ—ó: {str(e)}")
        return False

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ñ–≤ –≤—ñ–¥–µ–æ
def calculate_optimal_bitrate(duration, target_size_mb=45):
    # –ó–∞–ª–∏—à–∞—î–º–æ –∑–∞–ø–∞—Å —É 5MB –≤—ñ–¥ –ª—ñ–º—ñ—Ç—É 50MB
    target_size_bytes = target_size_mb * 1024 * 1024
    # –ü—Ä–∏–±–ª–∏–∑–Ω–∏–π –æ–≤–µ—Ä—Ö–µ–¥ –∞—É–¥—ñ–æ (192kbps)
    audio_bitrate_bytes = 192 * 1024 / 8  # bytes per second
    
    # –û–±—á–∏—Å–ª—é—î–º–æ –¥–æ—Å—Ç—É–ø–Ω–∏–π –±—ñ—Ç—Ä–µ–π—Ç –¥–ª—è –≤—ñ–¥–µ–æ
    available_bytes = target_size_bytes - (duration * audio_bitrate_bytes)
    video_bitrate_bps = (available_bytes * 8) / duration
    
    # –û–±–º–µ–∂—É—î–º–æ –±—ñ—Ç—Ä–µ–π—Ç —Ä–æ–∑—É–º–Ω–∏–º–∏ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏
    min_bitrate = 800 * 1024   # Increased from 500 to 800 kbps
    max_bitrate = 4000 * 1024  # Increased from 3000 to 4000 kbps
    
    video_bitrate_bps = max(min_bitrate, min(video_bitrate_bps, max_bitrate))
    return int(video_bitrate_bps)

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–±–æ—Ä—É –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—ó —Ä–æ–∑–¥—ñ–ª—å–Ω–æ—ó –∑–¥–∞—Ç–Ω–æ—Å—Ç—ñ
def get_optimal_resolution(original_width, original_height, target_bitrate):
    # Always maintain original dimensions for initial compression
    return original_width, original_height

# –§—É–Ω–∫—Ü—ñ—è –≤—ñ–¥–º—ñ–Ω–∏ –æ–ø–µ—Ä–∞—Ü—ñ—ó
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('–û–ø–µ—Ä–∞—Ü—ñ—é —Å–∫–∞—Å–æ–≤–∞–Ω–æ.')
    return ConversationHandler.END

def main() -> None:
    token = os.environ.get("TELEGRAM_BOT_TOKEN", "YOUR_TOKEN_HERE")
    application = Application.builder().token(token).build()
    
    # Add a separate handler for the main menu button that takes precedence over others
    application.add_handler(MessageHandler(
        filters.Regex("^üîÑ –ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é$"),
        start,
        block=False
    ))
    
    # Update conversation handler to remove YouTube
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            CallbackQueryHandler(instagram_button, pattern="^instagram$"),
            CallbackQueryHandler(tiktok_button, pattern="^tiktok$")
        ],
        states={
            WAITING_FOR_INSTAGRAM_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_instagram_link)],
            WAITING_FOR_TIKTOK_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_tiktok_link)]
        },
        fallbacks=[CommandHandler("cancel", cancel)]
    )
    
    application.add_handler(conv_handler)
    
    # Update inline button handlers
    application.add_handler(CallbackQueryHandler(instagram_button, pattern="^instagram$"))
    application.add_handler(CallbackQueryHandler(tiktok_button, pattern="^tiktok$"))
    
    application.run_polling()

if __name__ == "__main__":
    main()



